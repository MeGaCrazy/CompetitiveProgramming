/***
*   Idea : Just Format the input and then For Every Polyline Check if they are connected by Checking 
*          each segment .. To check How many Groupes are connected Use Union Find disjoint sets :) 
*
*   CornerCase : Take Care of polyline of One Point :)
*
***/


#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <string>
#include <string.h>
using namespace std;
const int N=1055;


struct point{
  int x,y;
  point(int x=0,int y=0):x(x),y(y){}
  point operator -(point &other){
    return point(x-other.x,y-other.y);
  }
  bool operator ==(point &other){
    return x==other.x&&y==other.y;
  }

};
vector<point>poly[N];
int p[N],sz[N];
class PolylineUnion {
public:
         
       long long norm(point &v1){
          return 1ll*v1.x*v1.x+1ll*v1.y*v1.y;
       }
       long long cross(point &v1,point &v2){
           return 1ll*v1.x*v2.y-1ll*v1.y*v2.x;
       }
       int ccw(point &a,point &b,point &c){
          point v1=b-a;
          point v2=c-a;
          if(cross(v1,v2) >0)return 1;
          if(cross(v1,v2)< 0)return -1;
          if(v1.x*v2.x <0 || v1.y*v2.y <0)return -1;
          if(norm(v1) < norm(v2) )return 1;
          return  0;
       }
       bool Interseg(point &a,point &b,point &c,point &d){
          bool f1=(b==a),f2=(c==d);
          if(f1&&f2)return c==a;
          if(f1)return ccw(c,d,a)==0;
          if(f2)return ccw(a,b,d)==0;
          return ccw(a,b,c)*ccw(a,b,d)<=0&&
                 ccw(c,d,a)*ccw(c,d,b)<=0;
       }

       void Init(){
          for(int i=0;i<N;i++){
             p[i]=i;
             sz[i]=1;
          }
       }
       int Find(int i){
         return  p[i]==i?i:p[i]=Find(p[i]);
       }
       bool isSame(int i,int j){
        return  Find(i)==Find(j);
       }
       void Join(int i,int j){
          int x=Find(i),y=Find(j);
          if(sz[x] >=sz[y]){
             sz[x]+=sz[y];
             sz[y]=0;
             p[y]=x;
          }else{
             sz[y]+=sz[x];
             sz[x]=0;
             p[x]=y;
          }
       }

        bool Inter(int idx1,int idx2){
            for(int i=0;i<(int)poly[idx1].size()-1;i++){
                 point a=poly[idx1][i];
                 point b=poly[idx1][i+1];
                 for(int j=0;j<(int)poly[idx2].size()-1;j++){
                  point c=poly[idx2][j];
                  point d=poly[idx2][j+1];
                  if(Interseg(a,b,c,d))return 1;
                 }
                 if(poly[idx2].size()==1){
                   point c=poly[idx2][0];
                   if(Interseg(a,b,c,c))return 1;
                 }

            }
            if(poly[idx1].size()==1&&poly[idx2].size()==1){
               return poly[idx1][0]==poly[idx2][0];
            }
            return 0;
        }

	int countComponents(vector <string> p) {
	 string str="";
	 for(string s:p){
	     str+=s;
	 }
	  memset(poly,0,sizeof(poly));
	  int n=0;
       
           int num=0;
           int x,y;
           for(char c:str){
              if(c>='0'&&c<='9'){
                 num=(num*10)+(c-'0');
              }else if(c==' '){
                 y=num;
                 num=0;
                 poly[n].push_back(point(x,y));
                 n++;
              }else if(c==','){
                  x=num;
                  num=0;
              }else if(c=='-'){
                 y=num;
                 num=0;
                 poly[n].push_back(point(x,y));
              }
           }
           y=num;
           poly[n].push_back(point(x,y));
           n++;        
           Init();
          for(int i=0;i<n;i++){
              for(int j=0;j<n;j++){
                 if(i==j)continue;
                 if(poly[i].size()==0||poly[j].size()==0)continue;
                 if(Inter(i,j)&&!isSame(i,j)){
                   Join(i,j);
                 }
              }
          }
          int ans=0;
          for(int i=0;i<n;i++){
            if(poly[i].size()==0)continue;
            if(sz[i])ans++;
          }
          return ans;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	PolylineUnion *obj;
	int answer;
	obj = new PolylineUnion();
	clock_t startTime = clock();
	answer = obj->countComponents(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"0,0-10,10 0,10-10,0"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"0,0-10,5 5,0-15,5-10,10-5,5"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"1","3,0-5,5 4,0-4,20"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"10,0-10,1-9,2-9,3-8,4 ","8,2-9,2-10,3 ","12,2-11,2-9,1"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"0,0-10,0-0,0 20,0-8,0-20,0"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	string t0[] = {"1,1 2,2 3,3 4,4 3,3-4,4"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 3;
	all_right = KawigiEdit_RunTest(5, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 6 -----
	string t0[] = {"10,10-20,10 20,10-15,18 15,18-10,10"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(6, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 7 -----
	string t0[] = {"1,1 1,1"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(7, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
